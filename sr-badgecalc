#!/usr/bin/env python
# vim: ft=python expandtab softtabstop=0 tabstop=4 shiftwidth=4
#
# Copyright (c) 2016, Jon Nall 
# All rights reserved. 
# 
# Redistribution and use in source and binary forms, with or without 
# modification, are permitted provided that the following conditions are met: 
# 
#  * Redistributions of source code must retain the above copyright notice, 
#    this list of conditions and the following disclaimer. 
#  * Redistributions in binary form must reproduce the above copyright 
#    notice, this list of conditions and the following disclaimer in the 
#    documentation and/or other materials provided with the distribution. 
#  * Neither the name of  nor the names of its contributors may be used to 
#    endorse or promote products derived from this software without specific 
#    prior written permission. 
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
# POSSIBILITY OF SUCH DAMAGE. 


import argparse
import datetime
import dateutil
import json
import logging
import os
import sys
import yaml
from smashrun.client import Smashrun
from smashrun.badges import BadgeSet


def smashrun_client(client_id=None, client_secret=None, refresh_token=None, access_token=None):
    if client_id is None:
        raise ValueError("Must specify a valid client_id")
    if client_secret is None:
        raise ValueError("Must specify a valid client_secret")

    if refresh_token is None:
        raise RuntimeError("Must supply a token currently")
    else:
        client = Smashrun(client_id=client_id, client_secret=client_secret)
        client.refresh_token(refresh_token=refresh_token)
        return client


def parse_args(argv):
    parser = argparse.ArgumentParser()
    parser.add_argument('--badge-start-date', type=str,                  help='Start considering runs on or after this date for badges (YYYY/mm/dd)')
    parser.add_argument('--credentials_file', type=str, required=True,   help='The name of the file holding service credentials')
    parser.add_argument('--input',            type=str,                  help='The name of a JSON file holding activities to avoid querying Smashrun servers')
    parser.add_argument('--badgeid',          type=int, action='append', help='Test the specified badge ID. Can be specified multiple times')
    parser.add_argument('--debug',            action='store_true', help='Enable verbose debug')
    args = parser.parse_args()

    if not os.path.isfile(args.credentials_file):
        parser.error('No such credentials file: %s' % (args.credentials_file))
    if not os.path.isfile(args.input):
        parser.error('No such badge data file: %s' % (args.input))

    with open(args.credentials_file, 'r') as fh:
        setattr(args, 'credentials', yaml.load(fh))
        args.credentials.setdefault('smashrun', None)

    if args.badge_start_date:
        args.badge_start_date = datetime.datetime.strptime(args.badge_start_date, '%Y-%m-%d').replace(tzinfo=dateutil.tz.tzlocal())

    if args.badgeid is None:
        args.badgeid = []

    return args


def setup(argv):
    args = parse_args(argv)
    logging.basicConfig(filename='sr-badgecalc.log',
                        filemode='w',
                        level=logging.DEBUG if args.debug else logging.INFO)
    console = logging.StreamHandler()
    console.setLevel(logging.DEBUG if args.debug else logging.INFO)
    formatter = logging.Formatter('%(levelname)-8s %(message)s')
    console.setFormatter(formatter)
    logging.getLogger('').addHandler(console)

    return args


def main(args):
    smashrun = smashrun_client(**args.credentials['smashrun'])

    # Update user badges
    badgeset = BadgeSet(args.badge_start_date, args.credentials['google_apikey'], args.badgeid)
    for userbadge in smashrun.get_badges():
        badgeset.add_user_info(userbadge)

    start = datetime.datetime.now() - datetime.timedelta(days=335)
    logging.info("Retriving SmashRuns START: %s" % (start))
    activities = []
    if args.input:
        with open(args.input, 'r') as fh:
            # Assume these are sorted already
            activities = json.load(fh)
    else:
        for a in smashrun.get_activities(since=start):
            activities.append(a)

        # Reverse the activities to go through them oldest to newest
        activities.reverse()

    for a in activities:
        badgeset.add_activity(a)

    logging.info("ACQUIRED BADGES")
    logging.info("---------------")
    for b in sorted([x for x in badgeset.badges if x.acquired], key=lambda x: x.actualEarnedDate):
        logging.info("%s %s" % (b.actualEarnedDate.strftime('%Y-%m-%d'), b.name))

if __name__ == '__main__':
    sys.exit(main(setup(sys.argv[1:])))
